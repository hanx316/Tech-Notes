# Dockerfile 使用指南

我们不可能每一次创建镜像都一遍遍手动去执行 `docker commit` 命令，至少也应该要将创建镜像的命令保存下来作为一个脚本去执行，方便复用以及维护。

而 `docker commit` 本质上其实是将一个运行的容器当前的存储层保存为一个新的镜像，作为单独定制镜像使用还是繁琐了一些。

创建镜像的脚本需要能够清晰地描述定制镜像的各种行为。 Dockerfile 就是 Docker 提供用来创建镜像的这个脚本文件。

## Dockerfile 指令

关于如何使用 Dockerfile 来定制镜像可以查看 [Dockerfile 官方文档](https://docs.docker.com/engine/reference/builder/)。

官方还有一篇 Dockerfile 最佳实践的文档，推荐阅读 [Best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)。

下面是一些常用指令的使用说明。

### FROM

FROM 指令指定了定制镜像使用的基础镜像。

示例：

```
FROM node:8-alpine
```

基础镜像往往用来作为应用服务的运行环境镜像。可以在 [Docker Hub](https://hub.docker.com/) 上寻找 Docker 官方或者各种基础服务官方制作的基础镜像。

Docker 中还有一个叫做 `scratch` 的虚拟镜像，`FROM scratch` 表示不以任何镜像为基础来定制。

一个 Dockerfile 文件必须以 FROM 指令开头（仅 ARG 指令可以出现在 FROM 之前）。

### COPY

COPY 指令用于将构建镜像的上下文目录下的文件复制到镜像的目标路径下。

示例：

```
# 将上下文根路径下的 package.json 复制到镜像工作目录下
COPY package.json package.json

# 将上下文根路径下的 package.json 复制到镜像工作目录的 app 目录下
COPY package.json app

# 将上下文根路径下的 package.json 复制到镜像根路径的 app 目录下
COPY package.json /app

# 将上下文根路径下的 app.js package.json 复制到镜像工作目录的 app 目录下
COPY app.js package.json app/

# 将上下文根路径下的 config 目录复制到镜像工作目录的 app 目录下
COPY config app/config
# 或者
COPY config app/config/
```

COPY 指令的合法源路径必须在构建镜像的上下文目录下，源路径支持 GO 语言的 [filepath.Match](https://golang.org/pkg/path/filepath/#Match) 匹配规则。

COPY 指令的合法目标路径必须是绝对路径或者对于工作目录的相对路径，不以 `/` 结尾的目标路径会被解释为一个文件而非目录。

如果一次 COPY 包含多个源路径，则目标路径必须是一个目录（即以 `/` 结尾）。

如果源路径是一个目录，则会将目录下的所有内容复制到目标路径下，而非将源目录复制到目标路径下（这个坑特别注意，所以在 COPY 目录时需要每个目录单独写一条命令）。

### WORKDIR

WORKDIR 指令指定了构建镜像过程中的工作目录。

因为镜像是分层构建的，在构建上一层执行命令时改变了当前目录，在构建下一层时并不会主动继承这个改变，使用 WORKDIR 会将之后每一层构建的当前目录统一。

示例

```
WORKDIR /app
```

WORKDIR 可以多次执行，之后指定的如果是相对路径，会基于前面的绝对路径生成。

### RUN

RUN 指令顾名思义执行命令。

比较常用的写法是直接跟 Shell 格式的命令

示例

```
RUN touch hello.txt && \
    echo 'hello' > hello.txt
```

按照一般理解，上面也是可以写成：

```
RUN touch hello.txt
RUN echo 'hello' > hello.txt
```

但是由于 Dockerfile 中每一条指令都会创建一层新的存储层，所以在使用 RUN 指令时往往不会采用这样出现多条 RUN 指令的写法，因为这样会使每一条 RUN 指令都创建一层，导致镜像臃肿。

因此在使用 RUN 指令时，需要注意尽可能让所有命令在同一层执行，并且一些操作完成后尽可能删除不必要的文件。


to be continue...
